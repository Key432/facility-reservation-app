# Reactの基礎

ここでは、Reactの基礎的な内容をまとめます。
ただし現在主流な技術の、さらによく使うものだけに絞ったもののため、あいまいな点や、ほかに最適な手段が用意されている可能性があります。都度公式のドキュメント等を調べることをお勧めします。

また、ここでは簡便のため基本的にはJavaScriptで記載します。

## コンポーネントベース開発

Reactは当初「ReactはMVCのV」、すなわちViewのためのライブラリであると、公式であるMetaも言っていました。しかし、その本質はコンポーネントベースアーキテクチャという新しい概念をReactは提供しました。

コンポーネントとは、すなわち、「機能と見た目と状態」を保持したものです。Reactの（関数）コンポーネントを表す端的な表現として

```txt
UI = f(state)
```

というものがあります。すなわち、関数（機能）にstate（状態）を渡すことで、その状態に基づいてて提供すべき内容が計算され、UI（見た目）として返される、ということです。
以上を踏まえて、基本的なReactのコンポーネントを見ていきます。

!!! NOTE クラスコンポーネント
    Reactには「関数コンポーネント」と「クラスコンポーネント」という二種類のコンポーネントの定義方法があります。昔は関数コンポーネントは`state`を持たない、すなわち状態変化を管理できないスタティックなコンポーネントとしてしか存在できませんでしたが、2019年のアップデートで「Hooks」（後述）が実装され、クラスコンポーネントの優位性はほぼなくなりました。
    現在では古いプロジェクトの保守以外にクラスコンポーネントを新しく書く必要はほぼないため、ここでも記載は省略します。

## Reactの仕組み

関数コンポーネントとは戻り値に`JSX`を返す関数のことです。例えば以下のようになります。

```jsx
export default function HelloWorld() {
  return <h1>Hello World!</h1>
}
```

ここで`<h1>`というのは、HTMLタグに似ていますが、JSXというJavaScriptの拡張構文です。内部的にはオブジェクトリテラルに変換され、ルートにて「仮想DOM」という仮想のDOMツリーが形成されます。そのDOMツリーが本当のHTML上にある唯一のタグ属性に対してレンダーすることで、サイトが形成されています。

Next.jsではない、素のReact（Viteなど）でプロジェクトを作成した場合、以下のようなファイルになります。

index.html

```html
<html>
  <head><title>sample</title></head>
  <body>
    <div id="root"></div>
  </body>
</html>
```

root.jsx

```js
import App from ./App
const root = document.getElementbyID("root")
root.render(<App/>)
```

このように単一の実体だけのHTMLに対して仮想DOMを構築しレンダーする仕組みがReactの基本的なメカニズムです。

そして、各DOMツリーは監視されていて、状態に変更があるとその部分が再度レンダリングされます。これによって、非同期に各コンポーネントの描画を更新します。

## コンポーネントの書き方

JSXは基本的にはプレーンなHTMLが持っている属性をそのまま設定できます。ただし以下の違いがあります。

- ケバブケースはキャメルケースに変更されています
  - ただし`aria-label`のようなアクセシビリティ系はそのまま
- `for`属性はJSの予約語と衝突するので`htmlFor`に変更されています
- `calss`属性はJSの予約語と衝突するので`className`に変更されています

`className`はTailwindCSSでは特によく使うのでそういうものだと思ってください。

素のHTMLにも存在するタグは小文字ではじめ、自分で作ったコンポーネントは大文字で始めなければいけません。
そのため、基本的には関数コンポーネントは大文字で始めることが推奨されます。（デフォルトエクスポートした関数は呼び出し側で名前を変えられるので、関数を小文字で初めても良いですが……）

```jsx
import helloworld from "helloworld"
export default function Page(){
  return <div><helloworld/></div> // エラーになります
}
```

また、コンポーネントが返すJSXの親要素は一つである必要があります。親要素を複数持ちたいときは（`<div>`でくくってもいいですが、余計な`<div>`が増えてしまうので）、`<></>`でくくります。これを**React.Fragment**といいます。これは仮想DOM上ではくくられて管理されても実際のHTML上では描画されません

```jsx
export default function Page() {
  return (
    <>
      <h1>Hello World</h1>
      <p>This page is ...</p>
    </>
  )
}
```

なお、`<></>`ではなく`<React.Fragment></React.Fragment>`でくくっていても同じ意味です。

カスタムコンポーネントを外部から呼び出すことで、コンポーネントを分割することができます。
コンポーネントの分割をどのレベルで行うかは、**SOLID原則**、特に「単一責任の原則」が参考になります。すなわち、一つのコンポーネントは一つの役割のみを持たせることがベストプラクティスとされています。これによって、コンポーネントの再利用性を高め、ユニットレベルのテストなどが容易に行えるようになります。

また、`return`の中ではJSXのほかに`{}`でくくることで、JavaScriptの式を書くことができます。そして、`{}`で渡されたJavaSciptの変数や定数は文字や新たなJSXとして描画されます。
また、`{}`で渡された配列は展開されて描画されます。そのため、以下のようなことが可能になります。

```jsx
function List(){
  const fruits = ["りんご", "ぶどう", "バナナ"]
  return (
    <ul>
      {/* ちなみにJSX内のコメントアウトはこう */}
      {fruits.map(fruit => {
        return <li>{fruit}</li>
      })}
    </ul>
  )
}
```
これは以下のように描画されます。

```html
<ul>
  <li>りんご</li>
  <li>ぶどう</li>
  <li>バナナ</li>
</ul>
```

ただし、文を書くことはできません。そのため`return`の中で`for (; ;) {...}`を書くことはできません。
そのために、Reactでは`.map()`や`.filter()`などの配列のメソッドが多用されます。また、これらのメソッドはコンポーネントの副作用を無くし、純粋に保つことにも役立ちます。そのためこれらの使用法は慣れておいた方がよいです。JavaSciptの記法や仕様を利用した書き方などはソースコードのコメントでも都度記載しています。以下などは頻出です。

- `.map()`
- `.filter()`
- `.sort()`
- `.reduce()`
- 分割代入、残余引数
- 短絡評価、三項演算子
- スプレッド演算子
- Null合体演算子

## 子コンポーネントへの状態の受け渡し

こうして分割した子コンポーネントへの状態の受け渡しは`props`と呼ばれる方法で行います。これは、カスタムコンポーネントのJSXにHTMLの属性を書くように行います。子コンポーネントは関数の引数として`props`を受け取ります。

```jsx
function Page() {
  return <Heading color="red" label="Hello World" />
}

function Heading(props) {
  return <h1 style={{color: props.color}}>{props.label}</h1>
}
```

propsは子コンポーネントの第一引数にオブジェクトリテラルで渡されます。通常は以下のように分割代入で受け取ることが多いです。

```jsx
function Heading({ color, label }) {
  return <h1 style={{color: color}}>{label}</h1>
}
```

このようにすることで、（たとえばエラーの時は文字を赤くするというような）動的な変化を与えることができます。

## stateの管理

コンポーネント内での状態（state）は**React Hooks**と呼ばれるAPIに渡すことで管理されます。以下はボタンを押すとカウントが増えるコンポーネントです。

```jsx
import { useState } from "react"
function Counter() {
  [count, setCount] = useState(0)
  const handleClick = () => setCount(prev => prev + 1)
  return (
    <>
      <p>{count}</p>
      <button onClick={handleClick}>+1増やす</button>
    </>
  )
}
```

`useState()`は状態を保持するための仕組みを提供します。`useState()`は引数として初期値を受け取り、その状態を保持する定数とその定数の変更関数をタプル（二要素の配列）で渡します。

この`count`は変更できません。変更はすべて`setCount()`を通じて行います。ここでは、ボタンが押されると、`setCount()`を使って、数値を1増やす関数`handleClick`を、ボタンが押されたときに発火する関数を渡す属性である`onClick`に渡しています。

また、気を付けるべき点として、countの変更は即時ではありません。たとえば、以下のようにしても数値が3ずつ増えることはありません

```jsx
const handleClick = () => {
  setCount(count + 1)
  setCount(count + 1)
  setCount(count + 1)
}
```

レンダリングのタイミングはパフォーマンスやデータの取得タイミングにもかかわるため、コンポーネント設計の上で重要になります。

以下は、入力された文字列を上部に表示するコンポーネントです

```jsx
function Label() {
  const [label, setLabel] = useState("")
  const handleChange = (e) => {
    useState(e.target.value)
  }
  return (
    <>
      <p>{label}</p>
      <input value={lavel} onChange={handleChange}/>
    </>
  )
}
```

ここで、`e`とはイベントが発火したときに、そのイベントの情報が入った`event`と呼ばれる属性です。これを使って変更できます。

また、

```jsx
<input value={label} onChange={handleChange(e)}/>
```

とした場合動きません。なぜなら、変更が起きたときにすぐに関数が走り、それによってvalueが書き換えられ、それによってまたレンダリング……という無限のレンダリングが発生するためです。onChangeやonClickには関数そのものを与えます。onChangeに`e`を明示したいときは以下のようになります。

```jsx
<input value={label} onChange={(e) => handleChange(e)}/>
```

`e`を引数として`handleChange`をラップした無名関数を渡しているため動きます。

## state hooksとeffect hooks

Reactには2種類のHooksがあります。**State Hooks**と**Effect Hooks**です。State Hooksは前述した状態を管理するためのHooksで`useReducer()`などがほかにあります。Effect Hooksは副作用を管理するフックスです。

副作用とは、コンポーネントの冪等性が担保されない要因、と考えることができます。
コンポーネントは純粋関数である必要があります。すなわち、与えられた`props`によって、いつでも同じレンダリングを返すということです。

しかし、例えば時間によって処理を行う`setInterval()`や、外部からデータを取得する`fetch()`など、この原則を壊さざるを得ない場面があります。そういった場合に副作用のある処理を管理して行うのがEffect Hooksです。代表に`useEffect()`があります。

以下は親コンポーネントから渡された情報からPoke APIでポケモン情報を取得する際の例です。

```jsx
import { useEffect, useState } from "react"
function Info({ name }) {
  const [pokemon, setPokemon] = useState(null)
  useEffect(() => {
    async function fetchData(name){
      const res = await fetch(`https://pokeapi.co/api/v2/pokemon/${name}`)
      if (res.ok) {
        const json = res.json()
        setPokemon(json)
      }
    }
    fetchData()
  }, [name])
}
```

ここで、`useEffect()`の第二引数の`[name]`は依存配列というものです。これは内部の副作用処理が依存している変数を渡します。`useEffect()`はその値を監視し、変化があったときと最初にレンダリングされたときに第一引数に渡している関数を実行します。

すなわちここでは`name`の値が変わるとそのたびに`useEffect`が実行されデータがフェッチされます。依存する変数がないときは第二引数に`[]`を渡します。これによってコンポーネントがマウントされたときにだけ処理が実行されます。今回の場合もしも`[name]`を渡さない場合、`setPokemon`で情報をセットしたことで`pokemon`が変更され、それによってこのコンポーネントが再レンダリングされ、その時にまたフェッチされてデータがセットされ……という無限ループが発生します。

Reactでは、関数型プログラミングによる純粋関数の冪等性が技術の前提になっています。コンポーネントのライフサイクルや副作用についての理解を深める必要があります。

## カスタムフックス

前述してコンポーネントの分割による再利用性を述べましたが、実際にはロジック（機能）のみ再利用したいということもあります。こうしたものに応えるのが`Custom Hooks`です。これは自分でHooksを作ることができる機能です。
これによって、ロジックを外部ファイルに切り出し、ほかのコンポーネントで再利用することができます。

先のボタンをクリックするとカウントを増やすロジックをCustom Hooksにすると以下のようになります。

```jsx
import { useState } from "react"
export function useCounter(initNumber) {
  const [count, setCount] = useState(initNumber)

  const incrementCount = () => {
    setCount(prev => ++prev)
  }

  return [count, incrementCount]
}
```

これを使うには以下のようになります。

```jsx
import { useCounter } from "./useCounter"
function Counter() {
  const [count, incrementCount] = useCounter(0)
  return (
    <>
      <p>{count}</p>
      <button onClick={incrementCount}>1増やす</button>
    </>
  )
}
```

例えば、のちに「1減らすボタンを実装したい」と要求があれば、useCounterを編集すれば、それを使用するすべてのコンポーネントで使うことができます。

```jsx
import { useState } from "react"
export function useCounter(initNumber) {
  const [count, setCount] = useState(initNumber)

  const incrementCount = () => {
    setCount(prev => prev + 1)
  }

  const decrementCount = () => {
    setCount(prev => prev - 1)
  }

  return [count, {incrementCount, decrementCount}]
}
```

このようにロジックを別ファイルに隠蔽することで、見た目を書く人とロジックを書く人で役割を分担し、見た目を書く人は内部処理について知る必要なく与えられた関数を使うことができるようになります。
また、ロジックを外部に切り出すことでロジックと見た目の分離を進めることができます。これにより機能のみのテストが容易になり単一責任原則や疎結合を達成しやすくなります。

!!! NOTE カスタムフックの戻り値の渡し方
    上記の例では`return [count, {incrementCount, decrementCount}]`というように`useState()`にならったタプルの形で渡していますが、決まりはありません。すべてオブジェクトで渡すというやり方もよくあります

    ```jsx
    // ...省略
    /*
      補足
      このオブジェクトリテラルの書き方はKeyとそれに入れるValueを格納した変数が
      同名の時省略できるという機能を使っています。これを省略せずに書くと以下になります。
      
      return {
        count: count,
        incrementCount: incrementCount,
        decrementCount: decrementCount
      }
    */
    return {count, incrementCount, decrementCount}
    ```
    どのように値が返ってくるのかはチーム内でルールを決めたり、[JSDoc](https://www.typescriptlang.org/ja/docs/handbook/jsdoc-supported-types.html)を活用するなどで対応してください。

## 参考

[りあクト！ TypeScriptで始めるつらくないReact開発 第4版【② React基礎編】](https://booth.pm/ja/items/2368019)
[イラストで理解するSOLID原則](https://qiita.com/baby-degu/items/d058a62f145235a0f007)